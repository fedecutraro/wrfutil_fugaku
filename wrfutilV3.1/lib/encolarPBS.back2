#export QSUB_ROOT=/opt/pbs/default/bin//qsub
#export QSUB_ROOT=/opt/torque/bin/

queue (){
        QDEPEND=$(getDepend)
        test $QUEUE && 		echo "#PBS -q $QUEUE " >  ${QPROC_NAME}.pbs      						## Cola a la que se lo va a encolar
        test $PCODE && 		echo "#PBS -A $PCODE "  >>  ${QPROC_NAME}.pbs							## Codigo de Usuario/Cuanta si fuera necesario
        test $QPROC_NAME &&	echo "#PBS -N ${QPROC_NAME} "  >>  ${QPROC_NAME}.pbs						## Nombre del Job
        			echo "#PBS -m n " >>  ${QPROC_NAME}.pbs								## Cuando se manda mail (default = nunca)
        test $QWALLTIME && 	echo "#PBS -l walltime=${QWALLTIME} "  >>  ${QPROC_NAME}.pbs					## Tiempo estimado de corrida
        			echo "#PBS -l nodes=${QNODES}:ppn=${QPPN} "  >>  ${QPROC_NAME}.pbs					## Recursos que seran utilizados
        			echo "#PBS -j oe "  >>  ${QPROC_NAME}.pbs							## Redireccion de flujos de salida y error
        			echo "#PBS -o $BASEDIR/LOGS/ "  >>  ${QPROC_NAME}.pbs							## Redireccion de flujos de salida y error
        			echo "#PBS -v BASEDIR,NOMBRE,WRFUTILDIR"  >>  ${QPROC_NAME}.pbs					## Indica las variables que se heredan del enviroment
        			#echo "#PBS -V "  >>  ${QPROC_NAME}.pbs								## Indica que debe heredar todo el enviroment
        #test $QARRAY &&   	echo "#PBS -J $QARRAY"  >> ${QPROC_NAME}.pbs                         				## Genera un array de procesos en PBSPRO
        test  $(($QARRAY)) -ne 0 &&  echo "#PBS -t $QARRAY"  >> ${QPROC_NAME}.pbs                         			## Genera un array de procesos en PBS 
        			echo $QDEPEND  >>  ${QPROC_NAME}.pbs								## Indica la dependencia del Job
				echo 'test ! $WRFUTILCONF &&'" source $BASEDIR/config.env $NOMBRE" >>  ${QPROC_NAME}.pbs
				echo 'test ! $WRFUTILEXP &&'" source $BASEDIR/experimento.conf" >>  ${QPROC_NAME}.pbs
				echo 'test ! $WRFUTILENV &&'" source $BASEDIR/entorno.sh" >>  ${QPROC_NAME}.pbs
                                echo $QNODES $QPPN PEPE
                		echo "MPIEXE=\"$(which mpirun) -np $(($QNODES*$QPPN))\""  >> ${QPROC_NAME}.pbs                          	 ## Comando MPIRUN con cantidad de nodos y cores por nodos
        #test $QARRAY &&	echo 'ARRAYID=$PBS_ARRAY_INDEX'  >> ${QPROC_NAME}.pbs              #PBSPRO           
        test $(($QARRAY)) -ne 0  &&  echo 'ARRAYID=$PBS_ARRAYID'  >> ${QPROC_NAME}.pbs             #PBS 
	echo "${QSCRIPTCMD}" >> ${QPROC_NAME}.pbs
	echo 'echo "FIN" >'" ${BASEDIR}/PROCS/${QPROC_NAME}" >> ${QPROC_NAME}.pbs
	if [[ $EJECUTAR -ne 0 ]]
	then 
        	${QSUB_ROOT}/qsub ${QPROC_NAME}.pbs > ${BASEDIR}/PROCS/${QPROC_NAME}
	else
		echo "Recuerde encolar de la siguiente manera:"
		echo "${QSUB_ROOT}/qsub ${QPROC_NAME}.pbs > ${BASEDIR}/PROCS/${QPROC_NAME}"
	fi
}

getDepend(){
        depend=$(join_by $(name2PID))
	afterok="#PBS -W depend=afterok$(test -z ${depend##*[]*}  && echo 'array'):"
	test $depend && echo ${afterok}${depend}
}

name2PID(){
        for file in $(ls  ${BASEDIR}/PROCS/${QDEPEND_NAME} 2>/dev/null)
        do
                jid=$(cat $file 2>/dev/null)
		if ! [[ $jid = "FIN" ]]
		then 
                	estado=$(qstat -fx $jid 2> /dev/null |grep job_state |grep -E "R|H|Q" )
                	if ! [[ -z $estado ]]
                	then
                         	echo $jid
                	fi
		fi
        done
}

function join_by { local IFS=${LIFS};  echo "$*"; }

